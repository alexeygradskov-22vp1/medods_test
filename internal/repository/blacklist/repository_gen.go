// Code generated by generator, DO NOT EDIT.
package blacklist

import (
	"context"
	"database/sql"

	sq "github.com/Masterminds/squirrel"
)

type querier interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

type wildcard int

const (
	QuestionWildcard wildcard = iota + 1
	DollarWildcard
)

type CommandRepository struct {
	runner      querier
	placeholder wildcard
}

type QueryRepository struct {
	runner      querier
	placeholder wildcard
}

func NewCommand(db querier, wildcards ...wildcard) *CommandRepository {
	w := QuestionWildcard
	if len(wildcards) > 0 {
		w = wildcards[0]
	}

	return &CommandRepository{
		runner:      db,
		placeholder: w,
	}
}

func NewQuery(db querier, wildcards ...wildcard) *QueryRepository {
	w := QuestionWildcard
	if len(wildcards) > 0 {
		w = wildcards[0]
	}

	return &QueryRepository{
		runner:      db,
		placeholder: w,
	}
}

// BlacklistFiler represents the Blacklist filter.
type Filter struct {
	accesstoken            *string
	notaccesstoken         *string
	gtaccesstoken          *string
	ltaccesstoken          *string
	gteqaccesstoken        *string
	lteqaccesstoken        *string
	accesstokens           []string
	accesstokenorderByAsc  *string
	accesstokenorderByDesc *string
	limit                  *int
	offset                 *int
}

type FilterOpt func(f *Filter)

func NewFilter(opts ...FilterOpt) Filter {
	f := Filter{}
	for _, opt := range opts {
		opt(&f)
	}
	return f
}

func WithLimit(limit int) FilterOpt {
	c := limit
	return func(f *Filter) {
		f.limit = &c
	}
}
func WithOffset(offset int) FilterOpt {
	c := offset
	return func(f *Filter) {
		f.offset = &c
	}
}
func WithAccessToken(accesstoken string) FilterOpt {
	c := accesstoken
	return func(f *Filter) {
		f.accesstoken = &c
	}
}
func WithAccessTokenNot(accesstoken string) FilterOpt {
	c := accesstoken
	return func(f *Filter) {
		f.notaccesstoken = &c
	}
}
func WithAccessTokenMoreThen(accesstoken string) FilterOpt {
	c := accesstoken
	return func(f *Filter) {
		f.gtaccesstoken = &c
	}
}
func WithAccessTokenLowerThen(accesstoken string) FilterOpt {
	c := accesstoken
	return func(f *Filter) {
		f.ltaccesstoken = &c
	}
}
func WithAccessTokenMoreOrEqualThen(accesstoken string) FilterOpt {
	c := accesstoken
	return func(f *Filter) {
		f.gteqaccesstoken = &c
	}
}
func WithAccessTokenLowerOrEqualThen(accesstoken string) FilterOpt {
	c := accesstoken
	return func(f *Filter) {
		f.lteqaccesstoken = &c
	}
}
func WithAccessTokens(accesstokens ...string) FilterOpt {
	return func(f *Filter) {
		f.accesstokens = append(f.accesstokens, accesstokens...)
	}
}

func WithOrderByAccessTokenAsc() FilterOpt {
	return func(f *Filter) {
		var column string = "access_token ASC"
		f.accesstokenorderByAsc = &column
	}
}
func WithOrderByAccessTokenDesc() FilterOpt {
	return func(f *Filter) {
		var column string = "access_token DESC"
		f.accesstokenorderByDesc = &column
	}
}

func applyWhere[B interface {
	Where(pred interface{}, args ...interface{}) B
	Limit(limit uint64) B
	Offset(limit uint64) B
	OrderBy(orderBys ...string) B
}](b B, f *Filter) B {
	if f.accesstoken != nil {
		b = b.Where(sq.Eq{ColumnBlacklistAccessToken: *f.accesstoken})
	}
	if f.notaccesstoken != nil {
		b = b.Where(sq.NotEq{ColumnBlacklistAccessToken: *f.notaccesstoken})
	}
	if f.ltaccesstoken != nil {
		b = b.Where(sq.Lt{ColumnBlacklistAccessToken: *f.ltaccesstoken})
	}
	if f.gtaccesstoken != nil {
		b = b.Where(sq.Gt{ColumnBlacklistAccessToken: *f.gtaccesstoken})
	}
	if f.lteqaccesstoken != nil {
		b = b.Where(sq.LtOrEq{ColumnBlacklistAccessToken: *f.lteqaccesstoken})
	}
	if f.gteqaccesstoken != nil {
		b = b.Where(sq.GtOrEq{ColumnBlacklistAccessToken: *f.gteqaccesstoken})
	}
	if f.accesstokens != nil {
		b = b.Where(sq.Eq{ColumnBlacklistAccessToken: f.accesstokens})
	}
	if f.accesstokenorderByAsc != nil {
		b = b.OrderBy(*f.accesstokenorderByAsc)
	}
	if f.accesstokenorderByDesc != nil {
		b = b.OrderBy(*f.accesstokenorderByDesc)
	}

	if f.limit != nil {
		b = b.Limit(uint64(*f.limit))
	}
	if f.offset != nil {
		b = b.Offset(uint64(*f.offset))
	}

	return b
}

type UpdateOpt func(u *Update)

// BlacklistUpdate represents the Blacklist update struct.
type Update struct {
	accesstoken *string
}

func NewUpdate(opts ...UpdateOpt) Update {
	u := &Update{}
	for _, opt := range opts {
		opt(u)
	}
	return *u
}
func WithUpdateAccessToken(accesstoken string) UpdateOpt {
	return func(f *Update) {
		f.accesstoken = &accesstoken
	}
}

func applySet[B interface {
	Set(column string, value interface{}) B
}](b B, f *Update) B {
	if f.accesstoken != nil {
		b = b.Set(ColumnBlacklistAccessToken, *f.accesstoken)
	}

	return b
}
