// Code generated by go generate; DO NOT EDIT.
package user

import (
	"context"
	"errors"
	"fmt"

	sq "github.com/Masterminds/squirrel"
)

// builderParams represents optional query parameters.
type BuilderParams struct {
	OrderBy    *string // Column and direction for sorting (e.g., "id ASC")
	SearchCol  *string // Column to search in (e.g., "name")
	SearchTerm *string // Term to search for (e.g., "alice")
	Offset     *int    // Initial offset for pagination
	Limit      *int    // Number of rows to fetch per batch
	MaxRows    *int
}

type Cursor struct {
	pool      querier
	builder   sq.SelectBuilder
	rows      []User
	index     int
	offset    int
	limit     int
	params    BuilderParams
	ctx       context.Context
	totalRows int
	closed    bool
}

func (r *CommandRepository) NewCursor(ctx context.Context, params BuilderParams, opts ...FilterOpt) *Cursor {
	limit := 10
	if params.Limit != nil {
		limit = *params.Limit
	}

	offset := 0
	if params.Offset != nil {
		offset = *params.Offset
	}
	var b sq.SelectBuilder
	switch r.placeholder {
	case DollarWildcard:
		b = sq.Select(
			ColumnUserGuid,
		).From(TableUser).PlaceholderFormat(sq.Dollar)
	default:
		b = sq.Select(
			ColumnUserGuid,
		).From(TableUser).PlaceholderFormat(sq.Question)
	}

	f := Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](&f)
	}
	b = applyWhere(b, &f)

	return &Cursor{
		pool:      r.runner,
		builder:   b,
		rows:      make([]User, 0, limit),
		index:     -1,
		offset:    offset,
		limit:     limit,
		params:    params,
		ctx:       ctx,
		totalRows: 0,
		closed:    false,
	}
}

func (r *QueryRepository) NewCursor(ctx context.Context, params BuilderParams, opts ...FilterOpt) *Cursor {
	limit := 10
	if params.Limit != nil {
		limit = *params.Limit
	}

	offset := 0
	if params.Offset != nil {
		offset = *params.Offset
	}

	var b sq.SelectBuilder
	switch r.placeholder {
	case DollarWildcard:
		b = sq.Select(
			ColumnUserGuid,
		).From(TableUser).PlaceholderFormat(sq.Dollar)
	default:
		b = sq.Select(
			ColumnUserGuid,
		).From(TableUser).PlaceholderFormat(sq.Question)
	}

	f := Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](&f)
	}
	b = applyWhere(b, &f)

	return &Cursor{
		pool:      r.runner,
		builder:   b,
		rows:      make([]User, 0, limit),
		index:     -1,
		offset:    offset,
		limit:     limit,
		params:    params,
		ctx:       ctx,
		totalRows: 0,
		closed:    false,
	}
}

func (c *Cursor) fetchRows() error {
	if c.closed {
		return errors.New("cursor is closed")
	}

	// Check if we've reached the maximum number of rows
	if c.params.MaxRows != nil && c.totalRows >= *c.params.MaxRows {
		return nil // No more rows to fetch
	}
	builder := c.builder

	if c.params.SearchCol != nil && c.params.SearchTerm != nil {
		builder = builder.Where(sq.ILike{*c.params.SearchCol: fmt.Sprintf("%%%s%%", *c.params.SearchTerm)})
	}

	if c.params.OrderBy != nil {
		builder = builder.OrderBy(*c.params.OrderBy)
	}
	remainingRows := c.limit
	if c.params.MaxRows != nil {
		remainingRows = *c.params.MaxRows - c.totalRows
		if remainingRows <= 0 {
			return nil
		}
		if remainingRows > c.limit {
			remainingRows = c.limit
		}
	}

	builder = builder.Limit(uint64(remainingRows)).Offset(uint64(c.offset))

	sql, args, err := builder.ToSql()
	if err != nil {
		return err
	}

	rows, err := c.pool.QueryContext(c.ctx, sql, args...)
	if err != nil {
		return err
	}
	defer rows.Close()

	c.rows = make([]User, 0, c.limit)
	for rows.Next() {
		var item User
		err := rows.Scan(
			&item.Guid,
		)
		if err != nil {
			return fmt.Errorf("error scanning row: %w", err)
		}
		c.totalRows++
		c.rows = append(c.rows, item)
	}

	if len(c.rows) > 0 {
		c.offset += remainingRows
	}
	return nil
}

func (c *Cursor) Next() bool {
	if c.closed {
		return false
	}

	// Check if we've reached the maximum number of rows
	if c.params.MaxRows != nil && c.totalRows >= *c.params.MaxRows && c.index >= len(c.rows)-1 {
		return false
	}
	if c.index >= len(c.rows)-1 {
		if err := c.fetchRows(); err != nil || len(c.rows) == 0 {
			return false
		}
		c.index = 0
		return true
	}

	c.index++
	return true
}

func (c *Cursor) Prev() bool {
	if c.closed {
		return false
	}
	if c.index > 0 {
		c.index--
		return true
	}
	return false
}

func (c *Cursor) Current() (User, error) {
	if c.closed {
		return User{}, errors.New("cursor is closed")
	}

	if c.index >= 0 && c.index < len(c.rows) {
		return c.rows[c.index], nil
	}
	return User{}, errors.New("not found")
}

func (c *Cursor) Reset() {
	if c.closed {
		return
	}

	c.index = -1
	c.offset = 0
	c.totalRows = 0
	c.rows = c.rows[:0] // Clear the slice while keeping the underlying array
}

// Close releases all resources held by the cursor.
func (c *Cursor) Close() {
	if c.closed {
		return
	}

	c.rows = nil // Free the memory held by the rows slice
	c.closed = true
}
