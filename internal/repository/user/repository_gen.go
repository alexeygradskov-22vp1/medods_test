// Code generated by generator, DO NOT EDIT.
package user

import (
	"context"
	"database/sql"

	sq "github.com/Masterminds/squirrel"
)

type querier interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

type wildcard int

const (
	QuestionWildcard wildcard = iota + 1
	DollarWildcard
)

type CommandRepository struct {
	runner      querier
	placeholder wildcard
}

type QueryRepository struct {
	runner      querier
	placeholder wildcard
}

func NewCommand(db querier, wildcards ...wildcard) *CommandRepository {
	w := QuestionWildcard
	if len(wildcards) > 0 {
		w = wildcards[0]
	}

	return &CommandRepository{
		runner:      db,
		placeholder: w,
	}
}

func NewQuery(db querier, wildcards ...wildcard) *QueryRepository {
	w := QuestionWildcard
	if len(wildcards) > 0 {
		w = wildcards[0]
	}

	return &QueryRepository{
		runner:      db,
		placeholder: w,
	}
}

// UserFiler represents the User filter.
type Filter struct {
	guid            *string
	notguid         *string
	gtguid          *string
	ltguid          *string
	gteqguid        *string
	lteqguid        *string
	guids           []string
	guidorderByAsc  *string
	guidorderByDesc *string
	limit           *int
	offset          *int
}

type FilterOpt func(f *Filter)

func NewFilter(opts ...FilterOpt) Filter {
	f := Filter{}
	for _, opt := range opts {
		opt(&f)
	}
	return f
}

func WithLimit(limit int) FilterOpt {
	c := limit
	return func(f *Filter) {
		f.limit = &c
	}
}
func WithOffset(offset int) FilterOpt {
	c := offset
	return func(f *Filter) {
		f.offset = &c
	}
}
func WithGuid(guid string) FilterOpt {
	c := guid
	return func(f *Filter) {
		f.guid = &c
	}
}
func WithGuidNot(guid string) FilterOpt {
	c := guid
	return func(f *Filter) {
		f.notguid = &c
	}
}
func WithGuidMoreThen(guid string) FilterOpt {
	c := guid
	return func(f *Filter) {
		f.gtguid = &c
	}
}
func WithGuidLowerThen(guid string) FilterOpt {
	c := guid
	return func(f *Filter) {
		f.ltguid = &c
	}
}
func WithGuidMoreOrEqualThen(guid string) FilterOpt {
	c := guid
	return func(f *Filter) {
		f.gteqguid = &c
	}
}
func WithGuidLowerOrEqualThen(guid string) FilterOpt {
	c := guid
	return func(f *Filter) {
		f.lteqguid = &c
	}
}
func WithGuids(guids ...string) FilterOpt {
	return func(f *Filter) {
		f.guids = append(f.guids, guids...)
	}
}

func WithOrderByGuidAsc() FilterOpt {
	return func(f *Filter) {
		var column string = "guid ASC"
		f.guidorderByAsc = &column
	}
}
func WithOrderByGuidDesc() FilterOpt {
	return func(f *Filter) {
		var column string = "guid DESC"
		f.guidorderByDesc = &column
	}
}

func applyWhere[B interface {
	Where(pred interface{}, args ...interface{}) B
	Limit(limit uint64) B
	Offset(limit uint64) B
	OrderBy(orderBys ...string) B
}](b B, f *Filter) B {
	if f.guid != nil {
		b = b.Where(sq.Eq{ColumnUserGuid: *f.guid})
	}
	if f.notguid != nil {
		b = b.Where(sq.NotEq{ColumnUserGuid: *f.notguid})
	}
	if f.ltguid != nil {
		b = b.Where(sq.Lt{ColumnUserGuid: *f.ltguid})
	}
	if f.gtguid != nil {
		b = b.Where(sq.Gt{ColumnUserGuid: *f.gtguid})
	}
	if f.lteqguid != nil {
		b = b.Where(sq.LtOrEq{ColumnUserGuid: *f.lteqguid})
	}
	if f.gteqguid != nil {
		b = b.Where(sq.GtOrEq{ColumnUserGuid: *f.gteqguid})
	}
	if f.guids != nil {
		b = b.Where(sq.Eq{ColumnUserGuid: f.guids})
	}
	if f.guidorderByAsc != nil {
		b = b.OrderBy(*f.guidorderByAsc)
	}
	if f.guidorderByDesc != nil {
		b = b.OrderBy(*f.guidorderByDesc)
	}

	if f.limit != nil {
		b = b.Limit(uint64(*f.limit))
	}
	if f.offset != nil {
		b = b.Offset(uint64(*f.offset))
	}

	return b
}

type UpdateOpt func(u *Update)

// UserUpdate represents the User update struct.
type Update struct {
	guid *string
}

func NewUpdate(opts ...UpdateOpt) Update {
	u := &Update{}
	for _, opt := range opts {
		opt(u)
	}
	return *u
}
func WithUpdateGuid(guid string) UpdateOpt {
	return func(f *Update) {
		f.guid = &guid
	}
}

func applySet[B interface {
	Set(column string, value interface{}) B
}](b B, f *Update) B {
	if f.guid != nil {
		b = b.Set(ColumnUserGuid, *f.guid)
	}

	return b
}
